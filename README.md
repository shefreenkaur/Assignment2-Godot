# COMP 360 Assignment 2 - 3D Glider Flight System

## Team Members and Actual Contributions

### Paramvir, Shefreen and Sahib

The following file gives details on how our code works including varibles, selected settings and main working of the code.
1. Flight Settings:
   
flight_height: The height at which the glider flies, fixed at 35 units above the ground. 

note: initially we set it at 20 which made the plane collide with the terrain (by collision we mean that the plane passes through the terrain

circle_radius: Defines how wide the circle is (set to 25 units).
(initially set to 40, however it moves the plane out of the terrain, the intitial scene doesn't appear as good)
flight_speed: How fast the glider moves along the path.

(All the settings can be adjusted)

2. Path Visual Settings:
   
dot_spacing: Controls how far apart the dots are along the path (set to 1 unit).
dot_size: Determines the size of each dot (set to 0.12 units).
path_color: The color of the dots along the path (set to a pinkish color).

(settings can be adjusted)

4. Main Variables:
center_x, center_z: These variables define the center of the circular path in the 3D space (50 units on the X-axis and 70 on the Z-axis).
path: A Path3D node that holds the curve defining the circular flight path.
path_follow: A PathFollow3D node that allows the glider to follow the path.
glider: The 3D model of the glider, which follows the path.

Main Functions:

_ready():
Clears any existing paths from the scene.
Calls create_circular_path() to generate the path for the glider.
Calls spawn_glider() to spawn the glider object and positions it correctly.

note: we tried various other functions to locate the plane, however this was the only one that worked fine, we took help from openAI for correcting this part of code.

Calls create_dotted_path() to generate and place the visual dots along the path.
Stores the initial position of the glider.

create_circular_path():
(Code generated by AI)
Path creation: Builds the circular path using a Curve3D.
The circle is generated by calculating points at regular angles around the center (center_x, center_z), at the height of flight_height.
Tangents (directions of movement) are calculated to ensure smooth curves and turns.
It creates a PathFollow3D node that will follow this curve continuously, using the loop option to allow it to repeat.

spawn_glider():
Glider setup: Loads the glider model from a scene file (glider.tscn), instantiates it, and places it at the start of the path.
The glider is positioned and rotated correctly to face forward along the path.
An extra Node3D (orientation_holder) is used to manage the glider’s orientation, keeping it aligned with the path’s direction.
(note: we tried other ways to 'fixing' the plane initially including just drag and drop of plane.glb, but due to errors further in code I wasn't able to further use it.
me(Shefreen), Paramvir and Sahib then collectively tried to work on it and finalised this method instead after trying other ways various times)

update_glider_movement(delta):
Glider movement: Moves the glider along the circular path.
The path_follow.progress is incremented based on flight_speed and the time passed (delta), allowing the glider to smoothly progress along the path.

_physics_process(delta):
Smooth movement update: This built-in function is called every frame. It simply calls update_glider_movement(delta) to update the glider’s position.
(I think this is might be the reason why our previous version wasn't smooth)

create_dotted_path():
Dotted path generation: Clears any existing visual path dots.
Calculates the total length of the path and determines how many dots should be placed along it based on dot_spacing.
For each dot, it calculates its position along the curve and creates a new dot (using create_dot()).

create_dot():
Dot creation: Creates a spherical mesh (using SphereMesh) to represent each dot along the path.
The material is set with glowing properties (emission) to make the dots appear as glowing spheres.
The created dot is added to the scene.

How the Script Works Together:
Circular Path Creation: At the start of the scene, a circular flight path is generated for the glider to follow. This is based on the parameters (center, radius, height).
Glider Spawning: A 3D glider is spawned at the beginning of this path and is aligned to move along it.
Dotted Path: As the glider flies along the circular path, glowing dots are placed along the path to visualize the glider's route.
Movement: The glider moves along the path over time, with its speed controlled by the flight_speed setting. The path is looped, so the glider keeps flying in a circle indefinitely

Shreyas Dutt, Manpreet Singh, Samardeep Sidhu, Sahibjeet Singh

Set up basic scene structure and camera system
Configured initial path parameters
Integrated and refined terrain generation, including terrain height mapping and texture blending
Worked on camera follow system
Assisted with path and terrain visualization
Contributed to terrain smoothing and scaling adjustments
## Actual Implementation Status

### Completed Features
1. Basic circular path implementation
2. Simple camera following system
3. Basic glider movement along path
4. Initial scene setup and organization
5. Red path visualization
6. Proper landscape fixes from Assignment 1

## Development Process

### Version Control
- Git repository: (https://github.com/shefreenkaur/Assignment2-Gadot)
- Branch structure for feature development



  ![image](https://github.com/user-attachments/assets/cc7f5244-c8ee-4b8b-9fed-4b63480d0fe9)


## Setup and Installation

1. **Environment Setup**
```bash
# Clone repository
git clone https://github.com/shefreenkaur/Assignment2-Gadot
# Open in Godot 4.x
# Run main scene
```

2. **Required Files**
- `flight_system.gd`
- `glider.tscn`
- `main.tscn`


## Git Integration Status

### Current Structure
- Main development branch
- Feature branches for:
  - Path generation
  - Glider movement
  - Camera system


