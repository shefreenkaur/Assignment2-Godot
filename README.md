# COMP 360 Assignment 2 - 3D Glider Flight System

# Glider Flight Simulation : Shefreen, Paramvir, and Sahibjeet

This project simulates the movement of a glider along a circular flight path, with visual dots representing the path. The settings and functionality of the code are explained below.

## 1. Flight Settings

- **`flight_height`**: The height at which the glider flies, fixed at 35 units above the ground.  
  *Note*: initially we set it at 20 which made the plane collide with the terrain (by collision we mean that the plane passes through the terrain)

- **`circle_radius`**: Defines the radius of the circular flight path, set to 25 units.  
  *Note*: (initially set to 40, however it moves the plane out of the terrain, the intitial scene doesn't appear as good)

- **`flight_speed`**: Controls how fast the glider moves along the path.  
  *Note*: All these setting can be adjusted for different speeds.

## 2. Path Visual Settings

- **`dot_spacing`**: Controls how far apart the dots are along the path, set to 1 unit.  
- **`dot_size`**: Determines the size of each dot, set to 0.12 units.  
- **`path_color`**: The color of the dots along the path, set to a pinkish color.

These settings can be adjusted to modify the visual appearance of the path.

## 3. Main Variables

- **`center_x`**, **`center_z`**: Define the center of the circular path in 3D space (50 units on the X-axis and 70 on the Z-axis).
- **`path`**: A `Path3D` node that holds the curve defining the circular flight path.
- **`path_follow`**: A `PathFollow3D` node that allows the glider to follow the path.
- **`glider`**: The 3D model of the glider, which follows the path.

## 4. Main Functions

### `_ready()`
- Clears any existing paths from the scene.
- Calls `create_circular_path()` to generate the flight path.
- Calls `spawn_glider()` to spawn and position the glider along the path.
- Calls `create_dotted_path()` to generate and place visual dots along the path.
- Stores the initial position of the glider.

### `create_circular_path()`
- Builds the circular path using a `Curve3D`.
- The circle is generated by calculating points at regular angles around the center (`center_x`, `center_z`), at the height of `flight_height`.
- Tangents (directions of movement) are calculated to ensure smooth curves and turns.
- It creates a `PathFollow3D` node that will follow this curve continuously, using the loop option to repeat the path.

### `spawn_glider()`
- Loads the glider model from a scene file (`glider.tscn`), instantiates it, and positions it at the start of the path.
- The glider is positioned and rotated correctly to face forward along the path.
- An extra `Node3D` (`orientation_holder`) is used to manage the glider’s orientation, keeping it aligned with the path’s direction.  
  *Note*: we tried other ways to 'fixing' the plane initially including just drag and drop of plane.glb, but due to errors further in code I wasn't able to further use it.
me(Shefreen), Paramvir and Sahib then collectively tried to work on it and finalised this method instead after trying other ways various times

### `update_glider_movement(delta)`
- Moves the glider along the circular path.
- The `path_follow.progress` is incremented based on `flight_speed` and the time passed (`delta`), allowing the glider to smoothly progress along the path.

### `_physics_process(delta)`
- This built-in function is called every frame.
- It simply calls `update_glider_movement(delta)` to update the glider’s position, ensuring smooth movement.

### `create_dotted_path()`
- Clears any existing visual path dots.
- Calculates the total length of the path and determines how many dots should be placed along it based on `dot_spacing`.
- For each dot, it calculates its position along the curve and creates a new dot (using `create_dot()`).

### `create_dot()`
- Creates a spherical mesh (using `SphereMesh`) to represent each dot along the path.
- The material is set with glowing properties (emission) to make the dots appear as glowing spheres.
- The created dot is added to the scene.

## How the Script Works Together

1. **Circular Path Creation**: At the start of the scene, a circular flight path is generated for the glider to follow. This is based on the parameters (`center_x`, `center_z`, `circle_radius`, `flight_height`).
   
2. **Glider Spawning**: A 3D glider is spawned at the beginning of this path and is aligned to move along it.

3. **Dotted Path**: As the glider flies along the circular path, glowing dots are placed along the path to visualize the glider's route.

4. **Movement**: The glider moves along the path over time, with its speed controlled by the `flight_speed` setting. The path is looped, so the glider keeps flying in a circle indefinitely.

## Notes

- The various settings (`flight_height`, `circle_radius`, `flight_speed`, etc.) can be adjusted to customize the behavior and appearance of the flight simulation.
- The use of `PathFollow3D` ensures smooth, continuous movement along the circular path.

---

## Terrain Generation Breakdown
# Shreyas, Manpreet, and Samardeep



### Overview

This section covers the generation of the terrain used in the 3D Glider Flight System. The terrain is procedurally generated using noise algorithms, and it incorporates various settings to control the size, height, and appearance of the terrain. The terrain is displayed as a mesh with a grid of quads, each representing a small part of the landscape.

### 1. **Grid Settings**

- **`grid_size`**: This variable defines the number of quads in the terrain grid, with default values of `200x200`. The terrain is constructed from these quads.
- **`quad_size`**: The size of each quad in the grid. A smaller value results in a more detailed terrain mesh.

### 2. **Height Settings**

- **`height_scale`**: Controls the vertical scaling of the terrain. The default value is `50.0`, and this affects how high or low the terrain can go.
- **`base_height`**: Sets the baseline height of the terrain. This allows for creating flat or elevated ground as a starting point before adding noise-based variations.

### 3. **Noise Settings**

- **`noise_scale`**: Controls the frequency of the noise used to generate the terrain. A larger value results in larger, less frequent noise features.
- **`noise_octaves`**: Specifies the number of noise layers to be applied, which allows for more complex and varied terrain features.
- **`noise_lacunarity`** and **`noise_gain`**: These control the roughness and intensity of the noise, respectively. Adjusting these values creates more or less pronounced terrain features.

### 4. **Generating the Height Map**

The `generate_height_map()` function creates the terrain's heightmap by using a FastNoiseLite object to generate 2D noise. The heightmap is calculated based on several factors:

- **Noise Generation**: Noise is generated using the `noise.get_noise_2d()` function, which outputs a value between -1 and 1. This value is scaled and smoothed to create more natural-looking terrain.
- **Distance-Based Modifications**: To make the terrain more interesting, the noise values are modified based on their distance from the center of the grid. A smooth falloff is applied to ensure the terrain is lower at the edges.
- **Edge Smoothing**: At the edges of the terrain, the height values are reduced to create a more natural boundary. This ensures the terrain smoothly transitions out to the edges rather than abruptly cutting off.

### 5. **Creating the Terrain Mesh**

The `create_terrain_mesh()` function is responsible for converting the heightmap into a 3D mesh, which will be displayed in the scene. Key steps include:

- **Vertices Generation**: For each point in the heightmap, a vertex is created at that point's coordinates. The vertex height is determined by the corresponding heightmap value.
- **Smoothing Heights**: Neighboring points' heights are averaged to smooth out sudden height changes, ensuring the terrain looks more natural.
- **Normals Calculation**: Normals are computed based on the surrounding terrain, allowing for realistic lighting and shading.
- **Mesh Creation**: The `ArrayMesh` is created using the generated vertices, texture coordinates, normals, and indices, forming a grid of triangles that represent the terrain surface.

### 6. **Adding Collision**

Once the terrain mesh is created, a `StaticBody3D` and `CollisionShape3D` are added to the scene. This ensures that the glider and other objects in the scene interact with the terrain, preventing them from passing through the ground.

### 7. **Material and Appearance**

The terrain is assigned a simple material with the following settings:

- **Albedo Color**: A slightly blue-tinted white color to simulate a snow-like appearance.
- **Roughness**: Set to 0.95, which makes the terrain appear rough and diffuse, similar to snow or rough terrain.
- **Shading Mode**: The material uses vertex colors for shading, ensuring the terrain can reflect the heightmap's variations visually.

### 8. **Regeneration**

The `regenerate()` function allows for the regeneration of the terrain mesh. This is useful for resetting or modifying the terrain dynamically, such as when the user changes the grid size or other settings.


## Actual Implementation Status

### Completed Features
1. Basic circular path implementation
2. Simple camera following system
3. Basic glider movement along path
4. Initial scene setup and organization
5. Red path visualization
6. Proper landscape fixes from Assignment 1

## Development Process

### Version Control
- Git repository: (https://github.com/shefreenkaur/Assignment2-Gadot)
- Branch structure for feature development



  ![image](https://github.com/user-attachments/assets/cc7f5244-c8ee-4b8b-9fed-4b63480d0fe9)


## Setup and Installation

1. **Environment Setup**
```bash
# Clone repository
git clone https://github.com/shefreenkaur/Assignment2-Gadot
# Open in Godot 4.x
# Run main scene
```

2. **Required Files**
- `flight_system.gd`
- `glider.tscn`
- `main.tscn`


## Git Integration Status

### Current Structure
- Main development branch
- Feature branches for:
  - Path generation
  - Glider movement
  - Camera system


